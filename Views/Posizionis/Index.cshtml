@model IEnumerable<poligono.Models.Posizionis>

@{
    ViewBag.Title = "Index";
}

<h2>Index</h2>
<link rel="stylesheet" href="http://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
      integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
      crossorigin="" />
<!-- Make sure you put this AFTER Leaflet's CSS -->
<script src="http://unpkg.com/leaflet@1.6.0/dist/leaflet.js"
        integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew=="
        crossorigin=""></script>
<link rel="stylesheet" href="http://leaflet.github.io/Leaflet.markercluster/dist/MarkerCluster.css">
<link rel="stylesheet" href="http://leaflet.github.io/Leaflet.markercluster/dist/MarkerCluster.Default.css">
<script src="http://leaflet.github.io/Leaflet.markercluster/dist/leaflet.markercluster-src.js"></script>

<p>
    @Html.ActionLink("Create New", "Create")
</p>
<table class="table">
    <tr>
        <th>
            @Html.DisplayNameFor(model => model.Lat)
        </th>
        <th>
            @Html.DisplayNameFor(model => model.Lon)
        </th>
        <th>
            @Html.DisplayNameFor(model => model.Tipo)
        </th>
        <th></th>
    </tr>
    @{int numeroPosizioni = 0; }
    @foreach (var item in Model)
    {
<tr>
    <td>
        @Html.DisplayFor(modelItem => item.Lat)
    </td>
    <td>
        @Html.DisplayFor(modelItem => item.Lon)
    </td>
    <td>
        @Html.DisplayFor(modelItem => item.Tipo)
    </td>
    <td>
        @Html.ActionLink("Edit", "Edit", new { id = item.ID }) |
        @Html.ActionLink("Details", "Details", new { id = item.ID }) |
        @Html.ActionLink("Delete", "Delete", new { id = item.ID })
    </td>
</tr>
        numeroPosizioni ++;
    }

</table>

@{
    /* prende le coordinate dal database e le assegna a un array*/
    string x;
    string y;
    string z;
    string tipo;
    Console.WriteLine(numeroPosizioni);
    string[] punti = new string[numeroPosizioni];
    int i = 0;
    //int j = 0;
    //Console.WriteLine(i);
    foreach (var item in Model)
    {
        x = item.Lat.ToString().Replace(",", ".");
        y = item.Lon.ToString().Replace(",", ".");
        tipo = item.Tipo.ToString();
        z = "[" + x + ", " + y + ", " + tipo + "]";
        Console.Write(x);
        Console.Write(y);
        Console.Write(tipo);
        Console.Write(z);
        punti[i] = z;
        Console.Write(punti);
        i++;
    };
    Console.WriteLine(i);
    Console.WriteLine(punti);
    string puntiStr = "";
    i = 0;
    /*trasforma l'array in una stringa così da poterlo passare al codice javascript*/
    foreach (var item in punti)
    {
        string text = punti[i];
        puntiStr = puntiStr + text + ", ";
        i++;
    }
    Console.WriteLine(puntiStr); 
    //Console.WriteLine(z);
    //string coordinata = "[45.4502977, 9.1675544]";
}
<div id="mapid"></div>
<style>
    #mapid {
        height: 1080px;
    }
</style>
<script src="http://www.openlayers.org/api/OpenLayers.js"></script>
<script type="text/javascript">
    /*funzione distanza*/
    function getDistance(origin, destination) {
    // return distance in meters
    var lon1 = toRadian(origin[1]),
        lat1 = toRadian(origin[0]),
        lon2 = toRadian(destination[1]),
        lat2 = toRadian(destination[0]);

    var deltaLat = lat2 - lat1;
    var deltaLon = lon2 - lon1;

    var a = Math.pow(Math.sin(deltaLat/2), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(deltaLon/2), 2);
    var c = 2 * Math.asin(Math.sqrt(a));
    var EARTH_RADIUS = 6371;
    return c * EARTH_RADIUS * 1000;
}
    function toRadian(degree) {
        return degree*Math.PI/180;
    }
    /* funzione per determinare se un punto si trova all'interno di un poligono */
    function isMarkerInsidePolygon(marker, poly) {
        var inside = false;
        var x = marker.getLatLng().lat, y = marker.getLatLng().lng;
        for (var ii=0;ii<poly.getLatLngs().length;ii++){
            var polyPoints = poly.getLatLngs()[ii];
            console.log(polyPoints);
            for (var i = 0, j = polyPoints.length - 1; i < polyPoints.length; j = i++) {
                var xi = polyPoints[i].lat, yi = polyPoints[i].lng;
                var xj = polyPoints[j].lat, yj = polyPoints[j].lng;

                var intersect = ((yi > y) != (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
        }

        return inside;
    };

    var puntijs = [@puntiStr];// ponte C# javascript
    console.log(puntijs);
    var mymap = L.map('mapid').setView(puntijs[0], 13);
    map = mymap;
    //var OsmLayer = new OpenLayers.Map("Mappa");
    L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}', {
        attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
        maxZoom: 18,
        id: 'mapbox/streets-v11',
        accessToken: 'pk.eyJ1Ijoia2lyb2xvc21hdGVyIiwiYSI6ImNqdzNxMXdtZzE5d2MzeXBndGd4YTh3dGMifQ.YW8rFAPQyZYz0ylkcqsk-g'
    }).addTo(mymap);
    //poligono che usa come vertici le coordinate del database
    //var poligonoPercorso = L.polygon([
    //    puntijs
    //], {stroke: true}).addTo(mymap);
    //console.log(poligonoPercorso);
    /* poligono che usa come vertici coordinate assegnate */
    var puntiAssegnati = [[45.4523599440727, 9.154427433314709],
    [45.45600255600573, 9.166078949272247],
    [45.46124027981537, 9.164405250864576],
    [45.4602168547772, 9.149835491461005]];
    var poligonoDefinito = L.polygon([
        puntiAssegnati
    ]).addTo(map);
    var perimetroPoligono = 0;
    for (var i = 0; i < puntiAssegnati.length; i++) {
        var j = i + 1;
        if (j >= puntiAssegnati.length) {
            j = 0;
        }
        var punto1 = puntiAssegnati[i];
        var punto2 = puntiAssegnati[j];
        var distanzaVerticiPoligono = getDistance(punto1, punto2);
        console.log(distanzaVerticiPoligono);
        perimetroPoligono += distanzaVerticiPoligono;
    }
    console.log(perimetroPoligono);
    //var distance = getDistance([lat1, lng1], [lat2, lng2])
    /*riferimento per aree e cluster http://leaflet.github.io/Leaflet.markercluster/example/marker-clustering-realworld.388.html */
    /* link icone marker https://www.iconfinder.com/icons/299087/map_marker_icon */
    var markers = L.markerClusterGroup();
    var centroArea = puntijs[0];
    var colore = ['blue', 'red', 'yellow', 'green'];
    var centri = new Array();
    var tipo = 0;
    for (var i = 0; i < puntijs.length; i++) {
        /*cluster di marker*/
        var puntiMatrice = puntijs[i];
        var marker = L.marker(new L.LatLng(puntiMatrice[0], puntiMatrice[1]));
        //console.log(marker);
        markers.addLayer(marker);
        //if (tipo != puntiMatrice[2]) {
        //    tipo = puntiMatrice[2];
        //    console.log(tipo);
        //    centri[tipo] = puntiMatrice;
        //    console.log(centri);
        //}
        //centroArea = centri[tipo];
        ///* crea l'area */
        //var distance = getDistance([puntiMatrice[0], puntiMatrice[1]], [centroArea[0], centroArea[1]]);
        //var raggio = 200;
        //if (distance > raggio) {
        //    raggio = distance + 200;
        //}
        ///* aree che si chiariscono all'aumentare della distanza dal centro */       
        //var areaGrande = L.circle(new L.LatLng(centroArea[0], centroArea[1]), { radius: raggio, stroke: false, color: colore[tipo] }).addTo(map);
        ///*cluster di cerchi*/
        ////var centriCerchi = puntijs[i];
        ////var centro = L.circle(new L.LatLng(centriCerchi[0], centriCerchi[1]), { radius: 200, stroke: false }).addTo(map);
        /* distanza punti poligono */
        /* determinazione posizione marker rispetto al poligono */
        var dentro = isMarkerInsidePolygon(marker, poligonoDefinito);
        console.log(dentro);
        if (dentro) {
            var alertMarkerInterno = L.circle(new L.LatLng(puntiMatrice[0], puntiMatrice[1]), { radius: 200, stroke: false, color: 'red' }).addTo(map);
        }
    }
    map.addLayer(markers);
    
    

    
	
</script>
